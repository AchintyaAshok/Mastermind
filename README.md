# Mastermind

## What is Mastermind?
Mastermind is a game similar to hangman. In mastermind, like hangman, the objective is to guess the word or phrase. The difference, however, is that the only response you get for a guess is a value indicating the 'number' of correct letters in the guess (no positional information is given).

For instance, let's suppose the secret phrase is 'hello world'. You guess 'hhhhh hhhhh' => response => 1. 1 indicates that exactly one character in your guess was a correct letter in the correct position (no indication as to which position).

Another difference is that you are not limited to guessing letters -- you can also guess a phrase or string of letters. For instance, my guess could be 'hello jello' or 'hello world', the latter case being an instance of me winning the game outlined previously.

## Install & Run
### Install
```bash
npm install
```
### Run
```bash
npm run play
```
You can set the difficulty for the randomly generated phrase by modifying the difficulty. This is the line annotated as 
```javascript
var myDifficulty = DIFFICULTY.insane
```
in play.js.

You may change this to any setting prescribed in DIFFICULTY: {trivial, easy, medium, difficult, insane}. Each successive difficulty lengthens the randomly generated phrase.

## High-Level Architecture
### Guess Engines
A guess engine is a plug-and-play module that you can define that will define and export two functions. The first function, initGuessEngine(), will be invoked when the websocket client gets created. The second function, handleMessage(), interprets the response to a guess from the websocket server. This should also kick-off the next guess generated by the engine.

At the moment, I have defined a single optimized engine, PhraseGuesserEngine. The less optimal LetterwiseEngine has yet to be implemented.

### PhraseGuesser
The purpose of this engine is to guess on a word-by-word basis rather than going by individual letters. If the guesses are optimized appropriately on each iteration, it dramatically reduces the number of guesses that need to be made. Initially, given a corpus of words, the engine groups them based on length:

```javascript
wordsByLength = [
  ["a"], // all words of length 1
  ["be", "go", "to"]
  ["cat", "bat", "par"],
  ["coal", "burn"], // all words of length 4
  // etc.
];
```

Next, it takes each array of words by length and determines how "close" each pair of words are. For a two words to score a higher score, they must have the same letter in the same position. Ex. "hello" & "jello" will score 4 because the letters "e", "l", "l", "o" in their respective positions match. "cat" & "ban" only match on "a" and will have a score of 1. By this methodology, each of the word lists is converted into a mapping of a word to all other words of same length:
```javascript
{
  "cat": [
    ["fun"], // 0 letters in common so housed at index 0
    ["ban", "fan"], // 1 letter in common
    ["pat"] // 2 letters in common
    // etc.
  ],
  "fun": [
    ["cat"],
    //etc.
  ],
};
```
This effectively allows us to model the relationships between words of equal length in terms of a graph. In this graph, each vertex is represented by a word. Each directed edge from the source vertex to the end vertex is annotated with the number of letters it has in common. For instance, "cat" has 2 letters in common with "ban". As you can see above, this is modeled like an adjacency list where the index of each list represents the number of letters in common with each of the words in the list.

Now, when you guess a word and get back a response indicating the number of letters that were correct, you can prune the next guess to the subset of nodes that have those many letters or more in common with the last guess. All such words are queued up in a guessQueue and we perform a BFS on the graph for each word in the phrase.


### LetterwiseEngine
This engine will iterate through all 26 letters in the alphabet for each word and determine if the letter in each position is correct. Therefore, the worst case runtime for this engine is 27^n where n is the length of the word.

### Choosing An Engine
Select the guess engine that you would like to use by changing the following line in play.js:
```javascript
var myGuessEngine = "phraseGuesser";
```

### Defining A New Engine
As long as your engine implements a initGuessEngine() method and a handleMessage() method, you will be set. initGuessEngine() should accept the websocket client handle and an array of words - the corpus. Your handleMessage() method is responsible for interpreting messages from the servers (responses from guesses) and then using the client handle passed in initGuessEngine() to send guesses.

Then, add your engine's javascript file as a module in factory.js:
```javascript
var MyCustomEngine = require(/* Path To My Engine */);
```

Finally, add a condition under the init() method of the factory to detect when the name of your engine is given as the type and to return the appropriate module.

### Mocked WebSocket Architecture
Instead of having to deal with annoying websocket client/server architecture then having to run the server on a port and have the client connect to that port, I mocked out a simple server/client framework that we use instead. Like the Node websocket library (ws), the client and server have event handlers with specific messages.

Specifically, the client listens for messages from the server marked as "serverMessage" and the server listens for messages from the client marked as "clientMessage". The latter is usually a guess string and the former is the response to a guess. I have used the EventEmitter library to architect this asynchronous event-based communication.

## Screenshots
Playing the game on trivial difficulty is easy!
![alt text](https://github.com/AchintyaAshok/Mastermind/blob/master/img/easy.png)

Insane is another game altogether. Can you beat this minimum amount of guesses?
![alt text](https://github.com/AchintyaAshok/Mastermind/blob/master/img/insane.png)
